Пузырьковая сортировка - это простой алгоритм сортировки, который применяется для упорядочивания элементов в заданном списке. Алгоритм получил свое название из-за способа, которым элементы "всплывают" на свои места, подобно пузырькам воды, в результате прохода по списку.
В пузырьковой сортировке происходят повторяющиеся проходы по списку. На каждом проходе сравниваются два соседних элемента и меняются местами, если они находятся в неправильном порядке. Большие элементы "всплывают" к концу списка, а меньшие элементы "опускаются" к его началу. Этот процесс повторяется до тех пор, пока список не будет полностью отсортирован.
Примеры пузырьковой сортировки:

1. Пузырьковая сортировка по возрастанию:
   Пусть у нас есть список чисел: [5, 2, 9, 1, 3]
   - На первом проходе сравниваются пары элементов [5, 2], [2, 9], [9, 1], [1, 3]. Происходят обмены и список становится: [2, 5, 1, 3, 9]
   - На втором проходе сравниваются пары элементов [2, 5], [5, 1], [1, 3], [3, 9]. Происходят обмены и список становится: [2, 1, 3, 5, 9]
   - На третьем проходе сравниваются пары элементов [2, 1], [1, 3], [3, 5], [5, 9]. Происходят обмены и список становится: [1, 2, 3, 5, 9]
   - На четвертом проходе сравниваются пары элементов [1, 2], [2, 3], [3, 5], [5, 9]. Никаких обменов не происходит, так как список уже отсортирован.
     Конечный результат: [1, 2, 3, 5, 9]
2. Пузырьковая сортировка по убыванию:
   Работает аналогично сортировке по возрастанию, но сравнение и обмен элементов происходит в обратном порядке. Процесс будет продолжаться до тех пор, пока на каждом проходе не будет производиться обмены.
   Например, для списка чисел [3, 8, 1, 6, 4]:
   - На первом проходе сравниваются пары элементов [3, 8], [8, 1], [1, 6], [6, 4]. Происходят обмены и список становится: [8, 3, 6, 4, 1]
   - На втором проходе сравниваются пары элементов [8, 3], [3, 6], [6, 4], [4, 1]. Происходят обмены и список становится: [8, 6, 4, 3, 1]
   - На третьем проходе сравниваются пары элементов [8, 6], [6, 4], [4, 3], [3, 1]. Происходят обмены и список становится: [8, 6, 4, 3, 1]
   - На четвертом проходе сравниваются пары элементов [8, 6], [6, 4], [4, 3], [3, 1]. Обмены не происходят, так как список уже отсортирован.
     Конечный результат: [8, 6, 4, 3, 1]

Важно отметить, что пузырьковая сортировка не является самым эффективным алгоритмом сортировки для больших списков, так как его время выполнения составляет O(n^2) в среднем и в худшем случае.

В JavaScript самой эффективной сортировкой для больших списков обычно считается быстрая сортировка (quick sort) или сортировка слиянием (merge sort).
Оба алгоритма имеют время выполнения O(n log n) в среднем и в худшем случае.
Быстрая сортировка основана на разделении списка на две части: элементы, меньшие или равные опорному элементу,
и элементы, большие опорного элемента.
Затем рекурсивно применяется алгоритм к обеим частям списка до тех пор, пока не будет достигнута базовая единица сортировки.
Быстрая сортировка является очень эффективной для случайных или хорошо смешанных списков.

Сортировка слиянием работает путем деления списка пополам, а затем слиянием отдельных половин для создания отсортированного списка. Процесс рекурсивно повторяется до тех пор, пока не будет достигнута базовая единица сортировки.
Сортировка слиянием хорошо подходит для списков, требующих стабильности сортировки или когда необходимо выполнить внешнюю сортировку.
Встроенный метод Array.prototype.sort() в JavaScript также использует различные алгоритмы сортировки, в зависимости от браузера или движка JavaScript.
Очень часто используется быстрая сортировка, но это может меняться в различных реализациях JavaScript.
Важно отметить, что выбор наиболее эффективной сортировки зависит от конкретных требований и размера списка данных. Если у вас есть особые условия или требования, может быть полезно проанализировать характеристики разных алгоритмов сортировки и их производительность для вашего конкретного случая.

В JavaScript существует несколько различных алгоритмов сортировки, каждый со своими преимуществами и недостатками. Выбор наиболее эффективного алгоритма зависит от конкретной задачи и объема данных, которые нужно отсортировать. Вот несколько примеров самых популярных алгоритмов сортировки в JavaScript:

1. Быстрая сортировка (Quick sort):

```javascript
function quickSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }

  const pivot = arr[arr.length - 1];
  const left = [];
  const right = [];

  for (let i = 0; i < arr.length - 1; i++) {
    if (arr[i] < pivot) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }

  return [...quickSort(left), pivot, ...quickSort(right)];
}
const unsortedArray = [5, 3, 8, 4, 2];
const sortedArray = quickSort(unsortedArray);
console.log(sortedArray); // Output: [2, 3, 4, 5, 8]
```

2. Сортировка слиянием (Merge sort):

```javascript
function mergeSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }

  const middle = Math.floor(arr.length / 2);
  const left = arr.slice(0, middle);
  const right = arr.slice(middle);

  return merge(mergeSort(left), mergeSort(right));
}
function merge(left, right) {
  const result = [];
  let leftIndex = 0;
  let rightIndex = 0;

  while (leftIndex < left.length && rightIndex < right.length) {
    if (left[leftIndex] <= right[rightIndex]) {
      result.push(left[leftIndex]);
      leftIndex++;
    } else {
      result.push(right[rightIndex]);
      rightIndex++;
    }
  }

  return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));
}
const unsortedArray = [5, 3, 8, 4, 2];
const sortedArray = mergeSort(unsortedArray);
console.log(sortedArray); // Output: [2, 3, 4, 5, 8]
```

3. Сортировка пузырьком (Bubble sort):

```javascript
function bubbleSort(arr) {
  const n = arr.length;

  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        const temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }

  return arr;
}
const unsortedArray = [5, 3, 8, 4, 2];
const sortedArray = bubbleSort(unsortedArray);
console.log(sortedArray); // Output: [2, 3, 4, 5, 8]
```

ЗАДАНИЕ 2.3

Давайте потренируем циклы и алгоритмы сортировки, плюс, попробуем описать происходящий процесс:

Необходимо отсортировать по убыванию сумму баллов, заработанных студентами за выполнение домашних заданий и получить отсортированный массив чисел для 24 студентов.

Создайте данный массив баллов (постарайтесь учесть разные бизнес-кейсы при выборе тестовых данных). У вас должен быть массив из 24 чисел-сумм баллов каждого студента за первые 2 модуля (фейковые данные). Нет необходимости делать объект с данными студентов (хотя, можно - по желанию) - работаем с массивом. Постарайтесь создать тестовый набор значений, так, что данные НУЖНО будет отсортировать

Реализуйте пузырьковую сортировку в убывающем порядке для данного массива.
Добавьте вывод в консоль в соответствующие места в коде следующую информацию:

- какую пару значений сравниваем в данной итерации
- какие индексы сравниваем в данной итерации
- на каком массиве будет пройдена текущая итерация
- какой массив получился в текущей итерации

Расставьте эти логи в нужных местах в коде, чтобы в консоли было понятно, что происходит с каждой итерацией цикла/ов.
Пример такого лога: \***\*\_\*\***новая итерация
сравниваем пару 2342 и 6
сравниваем индексы 0 и 1
работаем с массивом 2342,6,5675,85
получился промежуточный массив 6,2342,5675,85 \***\*\_\*\***новая итерация
сравниваем пару 2342 и 5675
сравниваем индексы 1 и 2
работаем с массивом 6,2342,5675,85
получился промежуточный массив 6,2342,5675,85 \***\*\_\*\***новая итерация
сравниваем пару 5675 и 85
сравниваем индексы 2 и 3
работаем с массивом 6,2342,5675,85
получился промежуточный массив 6,2342,85,5675 \***\*\_\*\***новая итерация
сравниваем пару 6 и 2342
сравниваем индексы 0 и 1
работаем с массивом 6,2342,85,5675
получился промежуточный массив 6,2342,85,5675 \***\*\_\*\***новая итерация
сравниваем пару 2342 и 85
сравниваем индексы 1 и 2
работаем с массивом 6,2342,85,5675
получился промежуточный массив 6,85,2342,5675 \***\*\_\*\***новая итерация
сравниваем пару 6 и 85
сравниваем индексы 0 и 1
работаем с массивом 6,85,2342,5675
получился промежуточный массив 6,85,2342,5675

Реализация пузырьковой сортировки для данного массива в убывающем порядке:

```javascript
let scores = [
  82, 56, 74, 68, 91, 45, 65, 89, 76, 60, 83, 70, 62, 87, 79, 72, 94, 54, 69,
  78, 86, 58, 75, 80,
];
console.log("Исходный массив:", scores);
let length = scores.length;
let sorted = false;
while (!sorted) {
  sorted = true;
  for (let i = 0; i < length - 1; i++) {
    console.log("_________новая итерация");
    console.log("Сравниваем пару", scores[i], "и", scores[i + 1]);
    console.log("Сравниваем индексы", i, "и", i + 1);
    console.log("Работаем с массивом", scores);
    if (scores[i] < scores[i + 1]) {
      let temp = scores[i];
      scores[i] = scores[i + 1];
      scores[i + 1] = temp;
      sorted = false;
    }
    console.log("Получился промежуточный массив", scores);
  }
  length--;
}
console.log("Отсортированный массив:", scores);
```

Вариант 2

```javascript
// Создание массива баллов студентов
let scores = [
  87, 95, 72, 80, 91, 68, 89, 93, 77, 85, 79, 88, 84, 76, 82, 90, 83, 70, 75,
  86, 92, 78, 94, 81,
];
console.log("Исходный массив баллов:", scores);
// Реализация пузырьковой сортировки в убывающем порядке
for (let i = 0; i < scores.length - 1; i++) {
  for (let j = 0; j < scores.length - i - 1; j++) {
    console.log("_________новая итерация");
    console.log("сравниваем пару", scores[j], "и", scores[j + 1]);
    console.log("сравниваем индексы", j, "и", j + 1);
    console.log("работаем с массивом", scores);
    // Сравнение двух соседних элементов
    if (scores[j] < scores[j + 1]) {
      // Обмен значений, если текущий элемент меньше следующего
      let temp = scores[j];
      scores[j] = scores[j + 1];
      scores[j + 1] = temp;
    }
    console.log("получился промежуточный массив", scores);
  }
}
console.log("Отсортированный массив баллов:", scores);
```

В данном примере используется массив баллов, состоящий из 24 чисел. Каждое число представляет собой сумму баллов, заработанных студентами за выполнение домашних заданий в первых двух модулях. Внутри двух вложенных циклов происходит сравнение пар соседних элементов, и в случае если текущий элемент меньше следующего, значения меняются местами. Это происходит до тех пор, пока массив не будет полностью отсортирован по убыванию.
В консоли будут отображены логи каждой итерации пузырьковой сортировки, включая сравнение пар значений, индексы и текущий массив после каждой итерации, чтобы было понятно, что происходит на каждом шаге сортировки.
